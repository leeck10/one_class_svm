/*
  File autogenerated by gengetopt version 2.20
  generated with the following command:
  C:\MinGW\msys\1.0\local\bin\gengetopt.exe -i one_class_svm.ggo -u -F cmdline 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "cmdline.h"

const char *gengetopt_args_info_purpose = "A command line utility to train/test one class SVM.";

const char *gengetopt_args_info_usage = "Usage: one_class_svm_tool [OPTIONS]... [FILES]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help             Print help and exit",
  "  -V, --version          Print version and exit",
  "\nTraining options:",
  "  -c, --cost=FLOAT       set Cost of one class SVM  (default=`1')",
  "  -m, --model=STRING     set model file name",
  "  -b, --binary           save/load model in binary format  (default=off)",
  "      --skip_eval        skip test set evaluation in the middle of training  \n                           (default=off)",
  "  -r, --random=INT       use random_shuffle in train_data (disabled if use 0)  \n                           (default=`0')",
  "      --train_num=INT    set number of sentence in train_data for training (for \n                           experiments) (disabled if use 0)  (default=`0')",
  "  -i, --iter=INT         iterations for training algorithm (sgd)  \n                           (default=`100')",
  "  -t, --tol=FLOAT        set Tolerance  (default=`1e-04')",
  "      --period=INT       save model periodically (sgd)  (default=`0')",
  "  -v, --verbose          verbose mode  (default=off)",
  "\nPredict options:",
  "  -o, --output=STRING    prediction output filename",
  "\none class SVM options:",
  "  -e, --epsilon=FLOAT    set epsilon  (default=`0.001')",
  "      --buf=INT          number of new constraints to accumulated before \n                           recomputing the QP (sgd)  (default=`10')",
  "      --rm_inactive=INT  inactive constraints are removed (iteration) (smo, \n                           one_slack_smo)  (default=`50')",
  "      --save_sv          save support vector (one_slack)  (default=off)",
  "\nKernel options:",
  "      --kernel=INT       kernel type (0=Linear 1=POLY 2=RBF 3=SIGMOID in SVMs)  \n                           (default=`0')",
  "      --gamma=FLOAT      gamma in RBF kernel (in SVMs)  (default=`1')",
  "      --coef=FLOAT       coef in POLY/SIGMOID kernel (in SVMs)  (default=`1')",
  "      --degree=INT       degree in POLY kernel (in SVMs)  (default=`3')",
  "\n Group: MODE",
  "  -p, --predict          prediction mode, default is training mode",
  "      --show             show-feature mode",
  "      --convert          convert mode ('txt model to bin model' or 'bin model \n                           to txt model (with -b)') and remove zero features \n                           (with --tol threshold)",
  "\n Group: Parameter Estimate Method",
  "      --one_slack        use 1-slack one class SVM without Gram matrix",
  "      --one_slack2       use 1-slack one class SVM using Gram matrix",
  "      --sgd              use SGD (Pegasos) in primal optimization (random \n                           shuffled train_data)",
  "      --sgd2             use Stachastic Gradient Descent (Pegasos) in primal \n                           optimization (pick random examples)",
    0
};

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error);


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->cost_given = 0 ;
  args_info->model_given = 0 ;
  args_info->binary_given = 0 ;
  args_info->skip_eval_given = 0 ;
  args_info->random_given = 0 ;
  args_info->train_num_given = 0 ;
  args_info->iter_given = 0 ;
  args_info->tol_given = 0 ;
  args_info->period_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->output_given = 0 ;
  args_info->epsilon_given = 0 ;
  args_info->buf_given = 0 ;
  args_info->rm_inactive_given = 0 ;
  args_info->save_sv_given = 0 ;
  args_info->kernel_given = 0 ;
  args_info->gamma_given = 0 ;
  args_info->coef_given = 0 ;
  args_info->degree_given = 0 ;
  args_info->predict_given = 0 ;
  args_info->show_given = 0 ;
  args_info->convert_given = 0 ;
  args_info->one_slack_given = 0 ;
  args_info->one_slack2_given = 0 ;
  args_info->sgd_given = 0 ;
  args_info->sgd2_given = 0 ;
  args_info->MODE_group_counter = 0 ;
  args_info->Parameter_Estimate_Method_group_counter = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->cost_arg = 1;
  args_info->cost_orig = NULL;
  args_info->model_arg = NULL;
  args_info->model_orig = NULL;
  args_info->binary_flag = 0;
  args_info->skip_eval_flag = 0;
  args_info->random_arg = 0;
  args_info->random_orig = NULL;
  args_info->train_num_arg = 0;
  args_info->train_num_orig = NULL;
  args_info->iter_arg = 100;
  args_info->iter_orig = NULL;
  args_info->tol_arg = 1e-04;
  args_info->tol_orig = NULL;
  args_info->period_arg = 0;
  args_info->period_orig = NULL;
  args_info->verbose_flag = 0;
  args_info->output_arg = NULL;
  args_info->output_orig = NULL;
  args_info->epsilon_arg = 0.001;
  args_info->epsilon_orig = NULL;
  args_info->buf_arg = 10;
  args_info->buf_orig = NULL;
  args_info->rm_inactive_arg = 50;
  args_info->rm_inactive_orig = NULL;
  args_info->save_sv_flag = 0;
  args_info->kernel_arg = 0;
  args_info->kernel_orig = NULL;
  args_info->gamma_arg = 1;
  args_info->gamma_orig = NULL;
  args_info->coef_arg = 1;
  args_info->coef_orig = NULL;
  args_info->degree_arg = 3;
  args_info->degree_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->cost_help = gengetopt_args_info_help[3] ;
  args_info->model_help = gengetopt_args_info_help[4] ;
  args_info->binary_help = gengetopt_args_info_help[5] ;
  args_info->skip_eval_help = gengetopt_args_info_help[6] ;
  args_info->random_help = gengetopt_args_info_help[7] ;
  args_info->train_num_help = gengetopt_args_info_help[8] ;
  args_info->iter_help = gengetopt_args_info_help[9] ;
  args_info->tol_help = gengetopt_args_info_help[10] ;
  args_info->period_help = gengetopt_args_info_help[11] ;
  args_info->verbose_help = gengetopt_args_info_help[12] ;
  args_info->output_help = gengetopt_args_info_help[14] ;
  args_info->epsilon_help = gengetopt_args_info_help[16] ;
  args_info->buf_help = gengetopt_args_info_help[17] ;
  args_info->rm_inactive_help = gengetopt_args_info_help[18] ;
  args_info->save_sv_help = gengetopt_args_info_help[19] ;
  args_info->kernel_help = gengetopt_args_info_help[21] ;
  args_info->gamma_help = gengetopt_args_info_help[22] ;
  args_info->coef_help = gengetopt_args_info_help[23] ;
  args_info->degree_help = gengetopt_args_info_help[24] ;
  args_info->predict_help = gengetopt_args_info_help[25] ;
  args_info->show_help = gengetopt_args_info_help[26] ;
  args_info->convert_help = gengetopt_args_info_help[27] ;
  args_info->one_slack_help = gengetopt_args_info_help[28] ;
  args_info->one_slack2_help = gengetopt_args_info_help[29] ;
  args_info->sgd_help = gengetopt_args_info_help[30] ;
  args_info->sgd2_help = gengetopt_args_info_help[31] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n", CMDLINE_PARSER_PACKAGE, CMDLINE_PARSER_VERSION);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  printf("\n%s\n\n", gengetopt_args_info_usage);

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);

  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = NULL;
  args_info->inputs_num = 0;
}

static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  
  unsigned int i;
  if (args_info->cost_orig)
    {
      free (args_info->cost_orig); /* free previous argument */
      args_info->cost_orig = 0;
    }
  if (args_info->model_arg)
    {
      free (args_info->model_arg); /* free previous argument */
      args_info->model_arg = 0;
    }
  if (args_info->model_orig)
    {
      free (args_info->model_orig); /* free previous argument */
      args_info->model_orig = 0;
    }
  if (args_info->random_orig)
    {
      free (args_info->random_orig); /* free previous argument */
      args_info->random_orig = 0;
    }
  if (args_info->train_num_orig)
    {
      free (args_info->train_num_orig); /* free previous argument */
      args_info->train_num_orig = 0;
    }
  if (args_info->iter_orig)
    {
      free (args_info->iter_orig); /* free previous argument */
      args_info->iter_orig = 0;
    }
  if (args_info->tol_orig)
    {
      free (args_info->tol_orig); /* free previous argument */
      args_info->tol_orig = 0;
    }
  if (args_info->period_orig)
    {
      free (args_info->period_orig); /* free previous argument */
      args_info->period_orig = 0;
    }
  if (args_info->output_arg)
    {
      free (args_info->output_arg); /* free previous argument */
      args_info->output_arg = 0;
    }
  if (args_info->output_orig)
    {
      free (args_info->output_orig); /* free previous argument */
      args_info->output_orig = 0;
    }
  if (args_info->epsilon_orig)
    {
      free (args_info->epsilon_orig); /* free previous argument */
      args_info->epsilon_orig = 0;
    }
  if (args_info->buf_orig)
    {
      free (args_info->buf_orig); /* free previous argument */
      args_info->buf_orig = 0;
    }
  if (args_info->rm_inactive_orig)
    {
      free (args_info->rm_inactive_orig); /* free previous argument */
      args_info->rm_inactive_orig = 0;
    }
  if (args_info->kernel_orig)
    {
      free (args_info->kernel_orig); /* free previous argument */
      args_info->kernel_orig = 0;
    }
  if (args_info->gamma_orig)
    {
      free (args_info->gamma_orig); /* free previous argument */
      args_info->gamma_orig = 0;
    }
  if (args_info->coef_orig)
    {
      free (args_info->coef_orig); /* free previous argument */
      args_info->coef_orig = 0;
    }
  if (args_info->degree_orig)
    {
      free (args_info->degree_orig); /* free previous argument */
      args_info->degree_orig = 0;
    }
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);
  
  if (args_info->inputs_num)
    free (args_info->inputs);
  
  clear_given (args_info);
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  if (args_info->help_given) {
    fprintf(outfile, "%s\n", "help");
  }
  if (args_info->version_given) {
    fprintf(outfile, "%s\n", "version");
  }
  if (args_info->cost_given) {
    if (args_info->cost_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "cost", args_info->cost_orig);
    } else {
      fprintf(outfile, "%s\n", "cost");
    }
  }
  if (args_info->model_given) {
    if (args_info->model_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "model", args_info->model_orig);
    } else {
      fprintf(outfile, "%s\n", "model");
    }
  }
  if (args_info->binary_given) {
    fprintf(outfile, "%s\n", "binary");
  }
  if (args_info->skip_eval_given) {
    fprintf(outfile, "%s\n", "skip_eval");
  }
  if (args_info->random_given) {
    if (args_info->random_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "random", args_info->random_orig);
    } else {
      fprintf(outfile, "%s\n", "random");
    }
  }
  if (args_info->train_num_given) {
    if (args_info->train_num_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "train_num", args_info->train_num_orig);
    } else {
      fprintf(outfile, "%s\n", "train_num");
    }
  }
  if (args_info->iter_given) {
    if (args_info->iter_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "iter", args_info->iter_orig);
    } else {
      fprintf(outfile, "%s\n", "iter");
    }
  }
  if (args_info->tol_given) {
    if (args_info->tol_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "tol", args_info->tol_orig);
    } else {
      fprintf(outfile, "%s\n", "tol");
    }
  }
  if (args_info->period_given) {
    if (args_info->period_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "period", args_info->period_orig);
    } else {
      fprintf(outfile, "%s\n", "period");
    }
  }
  if (args_info->verbose_given) {
    fprintf(outfile, "%s\n", "verbose");
  }
  if (args_info->output_given) {
    if (args_info->output_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "output", args_info->output_orig);
    } else {
      fprintf(outfile, "%s\n", "output");
    }
  }
  if (args_info->epsilon_given) {
    if (args_info->epsilon_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "epsilon", args_info->epsilon_orig);
    } else {
      fprintf(outfile, "%s\n", "epsilon");
    }
  }
  if (args_info->buf_given) {
    if (args_info->buf_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "buf", args_info->buf_orig);
    } else {
      fprintf(outfile, "%s\n", "buf");
    }
  }
  if (args_info->rm_inactive_given) {
    if (args_info->rm_inactive_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "rm_inactive", args_info->rm_inactive_orig);
    } else {
      fprintf(outfile, "%s\n", "rm_inactive");
    }
  }
  if (args_info->save_sv_given) {
    fprintf(outfile, "%s\n", "save_sv");
  }
  if (args_info->kernel_given) {
    if (args_info->kernel_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "kernel", args_info->kernel_orig);
    } else {
      fprintf(outfile, "%s\n", "kernel");
    }
  }
  if (args_info->gamma_given) {
    if (args_info->gamma_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "gamma", args_info->gamma_orig);
    } else {
      fprintf(outfile, "%s\n", "gamma");
    }
  }
  if (args_info->coef_given) {
    if (args_info->coef_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "coef", args_info->coef_orig);
    } else {
      fprintf(outfile, "%s\n", "coef");
    }
  }
  if (args_info->degree_given) {
    if (args_info->degree_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "degree", args_info->degree_orig);
    } else {
      fprintf(outfile, "%s\n", "degree");
    }
  }
  if (args_info->predict_given) {
    fprintf(outfile, "%s\n", "predict");
  }
  if (args_info->show_given) {
    fprintf(outfile, "%s\n", "show");
  }
  if (args_info->convert_given) {
    fprintf(outfile, "%s\n", "convert");
  }
  if (args_info->one_slack_given) {
    fprintf(outfile, "%s\n", "one_slack");
  }
  if (args_info->one_slack2_given) {
    fprintf(outfile, "%s\n", "one_slack2");
  }
  if (args_info->sgd_given) {
    fprintf(outfile, "%s\n", "sgd");
  }
  if (args_info->sgd2_given) {
    fprintf(outfile, "%s\n", "sgd2");
  }
  
  fclose (outfile);

  i = EXIT_SUCCESS;
  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}


/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static void
reset_group_MODE(struct gengetopt_args_info *args_info);

static void
reset_group_MODE(struct gengetopt_args_info *args_info)
{
  if (! args_info->MODE_group_counter)
    return;
  
  args_info->predict_given = 0 ;
  args_info->show_given = 0 ;
  args_info->convert_given = 0 ;

  args_info->MODE_group_counter = 0;
}

static void
reset_group_Parameter_Estimate_Method(struct gengetopt_args_info *args_info);

static void
reset_group_Parameter_Estimate_Method(struct gengetopt_args_info *args_info)
{
  if (! args_info->Parameter_Estimate_Method_group_counter)
    return;
  
  args_info->one_slack_given = 0 ;
  args_info->one_slack2_given = 0 ;
  args_info->sgd_given = 0 ;
  args_info->sgd2_given = 0 ;

  args_info->Parameter_Estimate_Method_group_counter = 0;
}

int
cmdline_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;

  result = cmdline_parser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  return EXIT_SUCCESS;
}

int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "cost",	1, NULL, 'c' },
        { "model",	1, NULL, 'm' },
        { "binary",	0, NULL, 'b' },
        { "skip_eval",	0, NULL, 0 },
        { "random",	1, NULL, 'r' },
        { "train_num",	1, NULL, 0 },
        { "iter",	1, NULL, 'i' },
        { "tol",	1, NULL, 't' },
        { "period",	1, NULL, 0 },
        { "verbose",	0, NULL, 'v' },
        { "output",	1, NULL, 'o' },
        { "epsilon",	1, NULL, 'e' },
        { "buf",	1, NULL, 0 },
        { "rm_inactive",	1, NULL, 0 },
        { "save_sv",	0, NULL, 0 },
        { "kernel",	1, NULL, 0 },
        { "gamma",	1, NULL, 0 },
        { "coef",	1, NULL, 0 },
        { "degree",	1, NULL, 0 },
        { "predict",	0, NULL, 'p' },
        { "show",	0, NULL, 0 },
        { "convert",	0, NULL, 0 },
        { "one_slack",	0, NULL, 0 },
        { "one_slack2",	0, NULL, 0 },
        { "sgd",	0, NULL, 0 },
        { "sgd2",	0, NULL, 0 },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hVc:m:br:i:t:vo:e:p", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'c':	/* set Cost of one class SVM.  */
          if (local_args_info.cost_given)
            {
              fprintf (stderr, "%s: `--cost' (`-c') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->cost_given && ! override)
            continue;
          local_args_info.cost_given = 1;
          args_info->cost_given = 1;
          args_info->cost_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->cost_orig)
            free (args_info->cost_orig); /* free previous string */
          args_info->cost_orig = gengetopt_strdup (optarg);
          break;

        case 'm':	/* set model file name.  */
          if (local_args_info.model_given)
            {
              fprintf (stderr, "%s: `--model' (`-m') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->model_given && ! override)
            continue;
          local_args_info.model_given = 1;
          args_info->model_given = 1;
          if (args_info->model_arg)
            free (args_info->model_arg); /* free previous string */
          args_info->model_arg = gengetopt_strdup (optarg);
          if (args_info->model_orig)
            free (args_info->model_orig); /* free previous string */
          args_info->model_orig = gengetopt_strdup (optarg);
          break;

        case 'b':	/* save/load model in binary format.  */
          if (local_args_info.binary_given)
            {
              fprintf (stderr, "%s: `--binary' (`-b') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->binary_given && ! override)
            continue;
          local_args_info.binary_given = 1;
          args_info->binary_given = 1;
          args_info->binary_flag = !(args_info->binary_flag);
          break;

        case 'r':	/* use random_shuffle in train_data (disabled if use 0).  */
          if (local_args_info.random_given)
            {
              fprintf (stderr, "%s: `--random' (`-r') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->random_given && ! override)
            continue;
          local_args_info.random_given = 1;
          args_info->random_given = 1;
          args_info->random_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->random_orig)
            free (args_info->random_orig); /* free previous string */
          args_info->random_orig = gengetopt_strdup (optarg);
          break;

        case 'i':	/* iterations for training algorithm (sgd).  */
          if (local_args_info.iter_given)
            {
              fprintf (stderr, "%s: `--iter' (`-i') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->iter_given && ! override)
            continue;
          local_args_info.iter_given = 1;
          args_info->iter_given = 1;
          args_info->iter_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->iter_orig)
            free (args_info->iter_orig); /* free previous string */
          args_info->iter_orig = gengetopt_strdup (optarg);
          break;

        case 't':	/* set Tolerance.  */
          if (local_args_info.tol_given)
            {
              fprintf (stderr, "%s: `--tol' (`-t') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->tol_given && ! override)
            continue;
          local_args_info.tol_given = 1;
          args_info->tol_given = 1;
          args_info->tol_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->tol_orig)
            free (args_info->tol_orig); /* free previous string */
          args_info->tol_orig = gengetopt_strdup (optarg);
          break;

        case 'v':	/* verbose mode.  */
          if (local_args_info.verbose_given)
            {
              fprintf (stderr, "%s: `--verbose' (`-v') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->verbose_given && ! override)
            continue;
          local_args_info.verbose_given = 1;
          args_info->verbose_given = 1;
          args_info->verbose_flag = !(args_info->verbose_flag);
          break;

        case 'o':	/* prediction output filename.  */
          if (local_args_info.output_given)
            {
              fprintf (stderr, "%s: `--output' (`-o') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->output_given && ! override)
            continue;
          local_args_info.output_given = 1;
          args_info->output_given = 1;
          if (args_info->output_arg)
            free (args_info->output_arg); /* free previous string */
          args_info->output_arg = gengetopt_strdup (optarg);
          if (args_info->output_orig)
            free (args_info->output_orig); /* free previous string */
          args_info->output_orig = gengetopt_strdup (optarg);
          break;

        case 'e':	/* set epsilon.  */
          if (local_args_info.epsilon_given)
            {
              fprintf (stderr, "%s: `--epsilon' (`-e') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->epsilon_given && ! override)
            continue;
          local_args_info.epsilon_given = 1;
          args_info->epsilon_given = 1;
          args_info->epsilon_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->epsilon_orig)
            free (args_info->epsilon_orig); /* free previous string */
          args_info->epsilon_orig = gengetopt_strdup (optarg);
          break;

        case 'p':	/* prediction mode, default is training mode.  */
          if (local_args_info.predict_given)
            {
              fprintf (stderr, "%s: `--predict' (`-p') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->predict_given && ! override)
            continue;
          local_args_info.predict_given = 1;
          args_info->predict_given = 1;
          if (args_info->MODE_group_counter && override)
            reset_group_MODE (args_info);
          args_info->MODE_group_counter += 1;
          break;


        case 0:	/* Long option with no short option */
          /* skip test set evaluation in the middle of training.  */
          if (strcmp (long_options[option_index].name, "skip_eval") == 0)
          {
            if (local_args_info.skip_eval_given)
              {
                fprintf (stderr, "%s: `--skip_eval' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->skip_eval_given && ! override)
              continue;
            local_args_info.skip_eval_given = 1;
            args_info->skip_eval_given = 1;
            args_info->skip_eval_flag = !(args_info->skip_eval_flag);
          }
          /* set number of sentence in train_data for training (for experiments) (disabled if use 0).  */
          else if (strcmp (long_options[option_index].name, "train_num") == 0)
          {
            if (local_args_info.train_num_given)
              {
                fprintf (stderr, "%s: `--train_num' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->train_num_given && ! override)
              continue;
            local_args_info.train_num_given = 1;
            args_info->train_num_given = 1;
            args_info->train_num_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->train_num_orig)
              free (args_info->train_num_orig); /* free previous string */
            args_info->train_num_orig = gengetopt_strdup (optarg);
          }
          /* save model periodically (sgd).  */
          else if (strcmp (long_options[option_index].name, "period") == 0)
          {
            if (local_args_info.period_given)
              {
                fprintf (stderr, "%s: `--period' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->period_given && ! override)
              continue;
            local_args_info.period_given = 1;
            args_info->period_given = 1;
            args_info->period_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->period_orig)
              free (args_info->period_orig); /* free previous string */
            args_info->period_orig = gengetopt_strdup (optarg);
          }
          /* number of new constraints to accumulated before recomputing the QP (sgd).  */
          else if (strcmp (long_options[option_index].name, "buf") == 0)
          {
            if (local_args_info.buf_given)
              {
                fprintf (stderr, "%s: `--buf' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->buf_given && ! override)
              continue;
            local_args_info.buf_given = 1;
            args_info->buf_given = 1;
            args_info->buf_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->buf_orig)
              free (args_info->buf_orig); /* free previous string */
            args_info->buf_orig = gengetopt_strdup (optarg);
          }
          /* inactive constraints are removed (iteration) (smo, one_slack_smo).  */
          else if (strcmp (long_options[option_index].name, "rm_inactive") == 0)
          {
            if (local_args_info.rm_inactive_given)
              {
                fprintf (stderr, "%s: `--rm_inactive' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rm_inactive_given && ! override)
              continue;
            local_args_info.rm_inactive_given = 1;
            args_info->rm_inactive_given = 1;
            args_info->rm_inactive_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->rm_inactive_orig)
              free (args_info->rm_inactive_orig); /* free previous string */
            args_info->rm_inactive_orig = gengetopt_strdup (optarg);
          }
          /* save support vector (one_slack).  */
          else if (strcmp (long_options[option_index].name, "save_sv") == 0)
          {
            if (local_args_info.save_sv_given)
              {
                fprintf (stderr, "%s: `--save_sv' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->save_sv_given && ! override)
              continue;
            local_args_info.save_sv_given = 1;
            args_info->save_sv_given = 1;
            args_info->save_sv_flag = !(args_info->save_sv_flag);
          }
          /* kernel type (0=Linear 1=POLY 2=RBF 3=SIGMOID in SVMs).  */
          else if (strcmp (long_options[option_index].name, "kernel") == 0)
          {
            if (local_args_info.kernel_given)
              {
                fprintf (stderr, "%s: `--kernel' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->kernel_given && ! override)
              continue;
            local_args_info.kernel_given = 1;
            args_info->kernel_given = 1;
            args_info->kernel_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->kernel_orig)
              free (args_info->kernel_orig); /* free previous string */
            args_info->kernel_orig = gengetopt_strdup (optarg);
          }
          /* gamma in RBF kernel (in SVMs).  */
          else if (strcmp (long_options[option_index].name, "gamma") == 0)
          {
            if (local_args_info.gamma_given)
              {
                fprintf (stderr, "%s: `--gamma' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->gamma_given && ! override)
              continue;
            local_args_info.gamma_given = 1;
            args_info->gamma_given = 1;
            args_info->gamma_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->gamma_orig)
              free (args_info->gamma_orig); /* free previous string */
            args_info->gamma_orig = gengetopt_strdup (optarg);
          }
          /* coef in POLY/SIGMOID kernel (in SVMs).  */
          else if (strcmp (long_options[option_index].name, "coef") == 0)
          {
            if (local_args_info.coef_given)
              {
                fprintf (stderr, "%s: `--coef' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->coef_given && ! override)
              continue;
            local_args_info.coef_given = 1;
            args_info->coef_given = 1;
            args_info->coef_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->coef_orig)
              free (args_info->coef_orig); /* free previous string */
            args_info->coef_orig = gengetopt_strdup (optarg);
          }
          /* degree in POLY kernel (in SVMs).  */
          else if (strcmp (long_options[option_index].name, "degree") == 0)
          {
            if (local_args_info.degree_given)
              {
                fprintf (stderr, "%s: `--degree' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->degree_given && ! override)
              continue;
            local_args_info.degree_given = 1;
            args_info->degree_given = 1;
            args_info->degree_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->degree_orig)
              free (args_info->degree_orig); /* free previous string */
            args_info->degree_orig = gengetopt_strdup (optarg);
          }
          /* show-feature mode.  */
          else if (strcmp (long_options[option_index].name, "show") == 0)
          {
            if (local_args_info.show_given)
              {
                fprintf (stderr, "%s: `--show' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->show_given && ! override)
              continue;
            local_args_info.show_given = 1;
            args_info->show_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* convert mode ('txt model to bin model' or 'bin model to txt model (with -b)') and remove zero features (with --tol threshold).  */
          else if (strcmp (long_options[option_index].name, "convert") == 0)
          {
            if (local_args_info.convert_given)
              {
                fprintf (stderr, "%s: `--convert' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->convert_given && ! override)
              continue;
            local_args_info.convert_given = 1;
            args_info->convert_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* use 1-slack one class SVM without Gram matrix.  */
          else if (strcmp (long_options[option_index].name, "one_slack") == 0)
          {
            if (local_args_info.one_slack_given)
              {
                fprintf (stderr, "%s: `--one_slack' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->one_slack_given && ! override)
              continue;
            local_args_info.one_slack_given = 1;
            args_info->one_slack_given = 1;
            if (args_info->Parameter_Estimate_Method_group_counter && override)
              reset_group_Parameter_Estimate_Method (args_info);
            args_info->Parameter_Estimate_Method_group_counter += 1;
            break;
          }
          /* use 1-slack one class SVM using Gram matrix.  */
          else if (strcmp (long_options[option_index].name, "one_slack2") == 0)
          {
            if (local_args_info.one_slack2_given)
              {
                fprintf (stderr, "%s: `--one_slack2' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->one_slack2_given && ! override)
              continue;
            local_args_info.one_slack2_given = 1;
            args_info->one_slack2_given = 1;
            if (args_info->Parameter_Estimate_Method_group_counter && override)
              reset_group_Parameter_Estimate_Method (args_info);
            args_info->Parameter_Estimate_Method_group_counter += 1;
            break;
          }
          /* use SGD (Pegasos) in primal optimization (random shuffled train_data).  */
          else if (strcmp (long_options[option_index].name, "sgd") == 0)
          {
            if (local_args_info.sgd_given)
              {
                fprintf (stderr, "%s: `--sgd' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->sgd_given && ! override)
              continue;
            local_args_info.sgd_given = 1;
            args_info->sgd_given = 1;
            if (args_info->Parameter_Estimate_Method_group_counter && override)
              reset_group_Parameter_Estimate_Method (args_info);
            args_info->Parameter_Estimate_Method_group_counter += 1;
            break;
          }
          /* use Stachastic Gradient Descent (Pegasos) in primal optimization (pick random examples).  */
          else if (strcmp (long_options[option_index].name, "sgd2") == 0)
          {
            if (local_args_info.sgd2_given)
              {
                fprintf (stderr, "%s: `--sgd2' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->sgd2_given && ! override)
              continue;
            local_args_info.sgd2_given = 1;
            args_info->sgd2_given = 1;
            if (args_info->Parameter_Estimate_Method_group_counter && override)
              reset_group_Parameter_Estimate_Method (args_info);
            args_info->Parameter_Estimate_Method_group_counter += 1;
            break;
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */

  if (args_info->MODE_group_counter > 1)
    {
      fprintf (stderr, "%s: %d options of group MODE were given. At most one is required.%s\n", argv[0], args_info->MODE_group_counter, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (args_info->Parameter_Estimate_Method_group_counter > 1)
    {
      fprintf (stderr, "%s: %d options of group Parameter Estimate Method were given. At most one is required.%s\n", argv[0], args_info->Parameter_Estimate_Method_group_counter, (additional_error ? additional_error : ""));
      error = 1;
    }
  



  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
